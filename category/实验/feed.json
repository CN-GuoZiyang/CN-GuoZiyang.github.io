{
    "version": "https://jsonfeed.org/version/1",
    "title": "菜狗の日常 • All posts by \"实验\" category",
    "description": "",
    "home_page_url": "https://ziyang.moe",
    "items": [
        {
            "id": "https://ziyang.moe/article/mapreducelab.html",
            "url": "https://ziyang.moe/article/mapreducelab.html",
            "title": "6.824 实验一 —— MapReduce",
            "date_published": "2022-01-20T14:29:04.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>实验一是要实现一个 MapReduce 系统，基本就是两个部分：实现 master 程序和实现 worker 程序。这个实验基本就是劝退怪了，一来是对 golang 的 rpc 和并发的使用要比较熟悉，二来就是要对 MapReduce 的整个流程机制要比较熟悉。其实有一个小秘诀，就是拼命看论文中的这张图，再拼命看下面的流程讲解：</p>\n<p><img data-src=\"https://tva1.sinaimg.cn/large/006VKfGmly1gyfq0cbiltj30y30n4wkx.jpg\" alt=\"MapReduce 执行流程，很重要很重要很重要\" title=\"MapReduce 执行流程，很重要很重要很重要\" width=\"500px\" /></p>\n<p>这个实验我实现了两个版本，主要是并发控制的方式有些不同。最初是基于 mutex 锁的版本，后来重构成了基于 channel 的无锁版本。无锁版本的实现比较优雅，所以讲解也主要基于无锁版本。</p>\n<h1 id=\"实验讲解\"><a class=\"anchor\" href=\"#实验讲解\">#</a> 实验讲解</h1>\n<p>做实验之前，首先需要读懂实验。说明书在：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjQvbGFicy9sYWItbXIuaHRtbCVFMyU4MCU4MiVFNCVCOCVCQiVFOCVBNiU4MSVFOCVCRiU5OSVFNCVCOCVBQSVFNSVBRSU5RSVFOSVBQSU4QyVFOSU5QyU4MCVFOCVBNiU4MSVFNSU5QyVBOA==\">https://pdos.csail.mit.edu/6.824/labs/lab-mr.html。主要这个实验需要在</span> Linux 环境下进行，因为进程通信基于 unix socket，MacOS 原则上来说也可以，但是据说还是会有些小问题。</p>\n<p>代码中已经提供了一个单线程串行版的 MapReduce，代码在  <code>src/main/mrsequential.go</code> 。这个版本很重要，建议先阅读一遍，可以大致了解整体的流程。有一些内容的处理也可以直接从中 copy。</p>\n<p>并行版本的 master 程序入口在  <code>main/mrcoordinator.go</code> ，worker 程序入口在  <code>main/mrworker.go</code> 。实验需要实现的有三个文件，分别是  <code>mr/coordinator.go</code> 、 <code>mr/worker.go</code> 、和  <code>mr/rpc.go</code> ，分别描述了 master 的处理代码、worker 的处理代码以及它们之间通信的 rpc 结构。</p>\n<p>mrcoordinator 会调用  <code>mr/coordinator.go</code>  中的 MakeCoordinator 函数，来构建 master 的结构，并启动 socket 监听，在返回后，主协程会不断调用 Coordinator.Done 方法，来检查是否已经完成整个 MapReduce 任务，确认完成后才会退出主协程。所以，在 MakeCoordinator 中，不应当有操作阻止函数返回，否则会阻塞后续操作。<strong>相关的监听等工作应当通过新协程实现</strong>。</p>\n<p>mrworker 的处理就很简单了，只有一个主协程，直接调用了  <code>mr/worker.go</code>  的 Worker 函数，在这里处理即可。一般可以直接实现成单协程程序。</p>\n<p>测试脚本为  <code>src/main/test-mr.sh</code> ，它会将两个现成的 MapReduce 程序：wc 和 indexer 通过你的框架执行，并与串行执行的结果相比较。它同时还会检查并行运行相同的 Map 或 Reduce 任务、甚至 worker 执行任务期间发生 crash 时，最终是否能得到正确的结构。通常它会启动一个 master 进程和三个 worker 进程。如果在运行期间发生错误不退出时，可以通过  <code>ps -A</code>  命令，找到 mrcoordinator 进程的 pid，并 kill 掉即可。普通的  <code>ctrl + c</code>  可能无法完全退出，会影响后续的测试。</p>\n<p>最后，请多阅读几遍实验指导书。</p>\n<h1 id=\"实现思路\"><a class=\"anchor\" href=\"#实现思路\">#</a> 实现思路</h1>\n<h2 id=\"整体流程\"><a class=\"anchor\" href=\"#整体流程\">#</a> 整体流程</h2>\n<p>workers 会首先执行完 map 任务，生成很多中间文件 “mr-X-Y”，其中，X 是 map 任务的 id，Y 是对应的 reduce 任务 id。接着 reduce 会收集所有 Y 等于 reduce 任务 id 的文件，读取并进行 reduce 操作，并将结果输出到 “mr-out-Y” 中。</p>\n<h2 id=\"master-实现\"><a class=\"anchor\" href=\"#master-实现\">#</a> master 实现</h2>\n<h3 id=\"无锁思路\"><a class=\"anchor\" href=\"#无锁思路\">#</a> 无锁思路</h3>\n<p>由于是一个无锁的实现，要避免多协程数据冲突，所有对主要数据结构的操作应当收敛到一个协程中，这里可以称为调度协程。在 worker 通过 rpc 请求 master 时，例如获取一个 task 或者汇报完成工作，master 会通过一个自动创建的协程处理 rpc 请求，由于对主要数据结构的操作已经收敛，这个 rpc 协程就必须通过 channel 要求调度协程代办，以保证没有数据竞争。由于 worker 和 master 之间可能有多种消息，这意味着调度协程必须同时管理多个 channel。这里可以运用 golang 的 select 结构：</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 只在这个 goroutine 中操作结构</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>Coordinator<span class=\"token punctuation\">)</span> <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> msg <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>c<span class=\"token punctuation\">.</span>getTaskChan<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\tc<span class=\"token punctuation\">.</span><span class=\"token function\">getTaskHandler</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> msg <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>c<span class=\"token punctuation\">.</span>doneTaskChan<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\tc<span class=\"token punctuation\">.</span><span class=\"token function\">doneTaskHandler</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> msg <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>c<span class=\"token punctuation\">.</span>timeoutChan<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\tc<span class=\"token punctuation\">.</span><span class=\"token function\">timeoutHandler</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> msg <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>c<span class=\"token punctuation\">.</span>doneCheckChan<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\tc<span class=\"token punctuation\">.</span><span class=\"token function\">doneCheckHandler</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>假设这时候有一个 worker 需要获取一个 task 来执行，请求 master 的 GetTask，GetTask 处理如下：</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>Coordinator<span class=\"token punctuation\">)</span> <span class=\"token function\">GetTask</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">_</span> <span class=\"token operator\">*</span>GetTaskReq<span class=\"token punctuation\">,</span> resp <span class=\"token operator\">*</span>GetTaskResp<span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tmsg <span class=\"token operator\">:=</span> GetTaskMsg<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\tresp<span class=\"token punctuation\">:</span> resp<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\tok<span class=\"token punctuation\">:</span>   <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tc<span class=\"token punctuation\">.</span>getTaskChan <span class=\"token operator\">&lt;-</span> msg</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token operator\">&lt;-</span>msg<span class=\"token punctuation\">.</span>ok</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在向 getTaskChan 中，不止传入了 resp（getTask 不需要请求参数），还传入了一个 chan struct {} 类型的管道，这个管道是协调协程用于通知 rpc 协程处理完成的通道：当处理完成后，就会向 msg.ok 中写入一个 struct {}，rpc 协程就会返回。</p>\n<h3 id=\"coordinator\"><a class=\"anchor\" href=\"#coordinator\">#</a> Coordinator</h3>\n<p>整个 Coordinator 结构如下：</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> Coordinator <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tnMap    <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tnReduce <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tphase   TaskPhase</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tallDone <span class=\"token builtin\">bool</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\ttaskTimeOut <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span>time<span class=\"token punctuation\">.</span>Time</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\ttasks       <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>Task</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\tgetTaskChan   <span class=\"token keyword\">chan</span> GetTaskMsg</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tdoneTaskChan  <span class=\"token keyword\">chan</span> DoneTaskMsg</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tdoneCheckChan <span class=\"token keyword\">chan</span> DoneCheckMsg</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\ttimeoutChan   <span class=\"token keyword\">chan</span> TimeoutMsg</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>phase 记录了当前任务执行的阶段，由于 reduce 任务必须在所有 map 任务结束后才能进行，所以 TaskPhase 分为 Map 和 Reduce 阶段，每个阶段中，tasks 切片只有对应阶段的任务。</p>\n<p>taskTimeOut 记录了当前正在执行的任务的开始时间，会有一个协程定时去扫描这个 map，找出其中运行时间大于十秒的任务（超时），将对应的任务状态设置为未开始，以进行下一次调度。当然这个扫描操作也需要通过协调协程进行。超时 map 中也只有当前阶段正在执行的任务，在切换阶段时会清空超时 map。</p>\n<p>tasks 切片保存了当前阶段所有的 Task，以及相关的状态：</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> ReduceTask <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tNMap <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">type</span> MapTask <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tFileName <span class=\"token builtin\">string</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tNReduce  <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">type</span> TaskStatus <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\tTaskStatus_Idle     TaskStatus <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\tTaskStatus_Running  TaskStatus <span class=\"token operator\">=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\tTaskStatus_Finished TaskStatus <span class=\"token operator\">=</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">type</span> Task <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\tTaskId     <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\tMapTask    MapTask</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\tReduceTask ReduceTask</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\tTaskStatus TaskStatus</pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里可以看到任务的状态被分成三个，分别是待执行、执行中以及执行完成。同时冗余保存了 MapTask 和 ReduceTask，具体使用哪个结构体由当前阶段来判断。</p>\n<h3 id=\"具体操作\"><a class=\"anchor\" href=\"#具体操作\">#</a> 具体操作</h3>\n<p>根据 Coordinator 中的管道，可以看出有四种情况需要和协调协程通信以进行操作。</p>\n<p>当 worker 请求一个任务时，可能获取到的任务类别有四种：</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> TaskType <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tTaskType_Map    TaskType <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tTaskType_Reduce TaskType <span class=\"token operator\">=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tTaskType_Wait   TaskType <span class=\"token operator\">=</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tTaskType_Exit   TaskType <span class=\"token operator\">=</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>master 首先遍历所有的 tasks，找出其中的状态为未执行的状态，并根据当前的阶段，返回 Map 或者 Reduce 任务。如果当前没有空闲任务的话，又分为以下两种情况。当前为 Map 阶段，这时需要返回 TaskType_Wait 任务，要求 worker 等待，Map 阶段结束后还需要进行 Reduce 任务；当前为 Reduce 阶段，这时所有任务已经完成，返回 TaskType_Exit 要求 worker 退出。</p>\n<p>当 worker 完成时，会通知 master 任务完成。传递的信息中会带有任务的类型和任务的 Id。master 会忽略掉非当前阶段的任务，根据 taskId 修改 tasks 中的任务状态为 finished（忽略当前任务状态，直接改为完成），并删除 timeout 中的对应结构。</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>Coordinator<span class=\"token punctuation\">)</span> <span class=\"token function\">doneTaskHandler</span><span class=\"token punctuation\">(</span>msg DoneTaskMsg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\treq <span class=\"token operator\">:=</span> msg<span class=\"token punctuation\">.</span>req</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">if</span> req<span class=\"token punctuation\">.</span>TaskType <span class=\"token operator\">==</span> TaskType_Map <span class=\"token operator\">&amp;&amp;</span> c<span class=\"token punctuation\">.</span>phase <span class=\"token operator\">==</span> TaskPhase_Reduce <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token comment\">// 提交非当前阶段的任务，直接返回</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\tmsg<span class=\"token punctuation\">.</span>ok <span class=\"token operator\">&lt;-</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> task <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> c<span class=\"token punctuation\">.</span>tasks <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> task<span class=\"token punctuation\">.</span>TaskId <span class=\"token operator\">==</span> req<span class=\"token punctuation\">.</span>TaskId <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\t<span class=\"token comment\">// 无论当前状态，直接改为完成</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t\ttask<span class=\"token punctuation\">.</span>TaskStatus <span class=\"token operator\">=</span> TaskStatus_Finished</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\t<span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token comment\">// 删除 timeout 结构</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>taskTimeOut<span class=\"token punctuation\">,</span> req<span class=\"token punctuation\">.</span>TaskId<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\tallDone <span class=\"token operator\">:=</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> task <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> c<span class=\"token punctuation\">.</span>tasks <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> task<span class=\"token punctuation\">.</span>TaskStatus <span class=\"token operator\">!=</span> TaskStatus_Finished <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t\tallDone <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t\t<span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t<span class=\"token keyword\">if</span> allDone <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> c<span class=\"token punctuation\">.</span>phase <span class=\"token operator\">==</span> TaskPhase_Map <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t\tc<span class=\"token punctuation\">.</span><span class=\"token function\">initReducePhase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t\t\tc<span class=\"token punctuation\">.</span>allDone <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\tmsg<span class=\"token punctuation\">.</span>ok <span class=\"token operator\">&lt;-</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果是在 Reduce 阶段发现所有任务都完成了，还会设置一下 allDone 标志位。</p>\n<p>Coordinator 在初始化时，还会启动一个协程，这个协程每秒请求一次协调协程，检查 timeoutMap 是否有超时任务，如果超时，就将其状态置为未开始，这样在下一次 worker 请求任务时就可以调度执行了。</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>Coordinator<span class=\"token punctuation\">)</span> <span class=\"token function\">timeoutHandler</span><span class=\"token punctuation\">(</span>msg TimeoutMsg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tnow <span class=\"token operator\">:=</span> time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">for</span> taskId<span class=\"token punctuation\">,</span> start <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> c<span class=\"token punctuation\">.</span>taskTimeOut <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> now<span class=\"token punctuation\">.</span><span class=\"token function\">Sub</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Seconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">10</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t\t<span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> task <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> c<span class=\"token punctuation\">.</span>tasks <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> taskId <span class=\"token operator\">==</span> task<span class=\"token punctuation\">.</span>TaskId <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t\t\t\t<span class=\"token keyword\">if</span> task<span class=\"token punctuation\">.</span>TaskStatus <span class=\"token operator\">!=</span> TaskStatus_Finished <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\t\t\t\ttask<span class=\"token punctuation\">.</span>TaskStatus <span class=\"token operator\">=</span> TaskStatus_Idle</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\t\t\t<span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t<span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>taskTimeOut<span class=\"token punctuation\">,</span> taskId<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t\t<span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\tmsg<span class=\"token punctuation\">.</span>ok <span class=\"token operator\">&lt;-</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>最后还有一个完成状态检查，是主线程调用 Coordinator.Done 进行的，请求协调协程时，只需要检查 allDone 标志位即可。</p>\n<h2 id=\"worker\"><a class=\"anchor\" href=\"#worker\">#</a> worker</h2>\n<p>worker 只有单个协程，循环从 master 处获取任务执行：</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">Worker</span><span class=\"token punctuation\">(</span>mapf <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>KeyValue<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\treducef <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\tresp <span class=\"token operator\">:=</span> <span class=\"token function\">callGetTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token keyword\">switch</span> resp<span class=\"token punctuation\">.</span>TaskType <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> TaskType_Map<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t\t<span class=\"token function\">handleMapTask</span><span class=\"token punctuation\">(</span>resp<span class=\"token punctuation\">.</span>Task<span class=\"token punctuation\">,</span> mapf<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> TaskType_Reduce<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\t<span class=\"token function\">handleReduceTask</span><span class=\"token punctuation\">(</span>resp<span class=\"token punctuation\">.</span>Task<span class=\"token punctuation\">,</span> reducef<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> TaskType_Wait<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> TaskType_Exit<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>map 和 reduce 的操作，可以参考串行单线程的实现。有一点注意是，由于可能有多个进程同时执行同一个任务，也可能会出现执行到一半崩溃的情况，遗留下的文件可能会导致后续 worker 重新执行时发生错误。所以创建输出文件时，可以通过 ioutil.TempFile 函数创建一个临时文件写入，等到写入完成后通过 os.Rename 重命名为目标文件，这样即可保证最后的输出文件一定是完整的。</p>\n",
            "tags": [
                "6.824",
                "mapreduce"
            ]
        },
        {
            "id": "https://ziyang.moe/article/csapplab0.html",
            "url": "https://ziyang.moe/article/csapplab0.html",
            "title": "CSAPP LAB —— 0. 实验环境搭建",
            "date_published": "2021-12-26T16:09:54.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<blockquote>\n<p>学 CSAPP 不做实验，就像四大名著不看红楼梦，说明这个人文学造诣和自我修养不足，他理解不了这种内在的阳春白雪的高雅艺术，他只能看到外表的辞藻堆砌，参不透其中深奥的精神内核，他整个人的层次就卡在这里了，只能度过一个相对失败的人生。</p>\n</blockquote>\n<p>劝退 CSAPP 实验人的最大因素，就是 Linux 环境。本科时候做过一次，用的是 Vmware Workstation 虚拟机平台，安装 Ubuntu Desktop。虽然我个人倒是没遇到过什么问题，但是身边的人遇到过一下问题：</p>\n<ul>\n<li>虚拟机安装错误</li>\n<li>Vmware 与 Hyper-v 不兼容</li>\n<li>虚拟机无网络</li>\n<li>虚拟机与宿主机共享文件夹不好使</li>\n<li>Ubuntu 中文输入法</li>\n<li>其他玄学问题</li>\n</ul>\n<p>另外，虚拟机的性能也是很难恭维，毕竟要从宿主机划出去一片内存，你永远不知道，是虚拟机先 OOM，还是宿主机先 OOM。</p>\n<p>综上，我选择 WSL（Windows Subsystem for Linux，适用于 Windows 的 Linux 子系统）。推荐的操作系统是 Windows 10 Version 2004 以上，或者 Windows 11，以使用 WSL 2。低于此版本的 Windows，即使有 WSL 功能，也只是 WSL 1，使用翻译层将 Linux 系统调用转化成 Windows 系统调用，而 WSL 2 使用了一个轻量级的、无需维护的虚拟机，并在这个虚拟机中运行了一个完整的 Linux 内核。一个完整的 Linux 内核，对于 CSAPP 的实验至关重要。</p>\n<p>什么，你问我 MacOS 怎么办，Intel 芯片的 MacBook 可以安装 VirtualBox、VMWare Fusion 或者 Parallel Desktop，并在其上安装 Linux 发行版，也可以使用 Docker。至于 m1 芯片的 MacBook，<strong>建议换电脑</strong>（不是开玩笑，m1 真的没法做实验）。</p>\n<p>笑死，我发现我废话就真多。</p>\n<h1 id=\"安装-wsl-和-ubuntu\"><a class=\"anchor\" href=\"#安装-wsl-和-ubuntu\">#</a> 安装 WSL 和 Ubuntu</h1>\n<p>Windows 安装 WSL 非常简单，只需要在一个有管理员权限的 PowerShell 中输入如下命令：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>wsl --install -d Ubuntu</pre></td></tr></table></figure><p>系统就会自动配置好所需的功能，并且自动下载 Ubuntu 的最新 LTS（截至本文写作时，版本 20.04）。在下载安装完成后，会弹出一个终端，要求你输入用户名和密码：</p>\n<pre><code>Installing, this may take a few minutes...\nPlease create a default UNIX user account. The username does not need to match your Windows username.\nFor more information visit: https://aka.ms/wslusers\nEnter new UNIX username: ziyang\nNew password:\nRetype new password:\npasswd: password updated successfully\nInstallation successful!\n</code></pre>\n<p>注意，输入密码时是不会显示在屏幕上的。</p>\n<p>配置完成后，一个  <code>ziyang@DESKTOP-4TMFLAE:~$</code>  样式的文字就出现了，等待你输入命令。至此，你已经进入了 Ubuntu 系统。</p>\n<h1 id=\"一些使用小技巧\"><a class=\"anchor\" href=\"#一些使用小技巧\">#</a> 一些使用小技巧</h1>\n<h2 id=\"windows-terminal\"><a class=\"anchor\" href=\"#windows-terminal\">#</a> Windows Terminal</h2>\n<p>Windows Terminal，可以说是 Windows 下的终端之王了。</p>\n<p>安装 Windows Terminal 可以直接在 Microsoft Store 中搜索 “Windows Terminal”，或者在其 Github Releases 页面：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC90ZXJtaW5hbC9yZWxlYXNlcyVFRiVCQyU4QyVFNCVCOCU4QiVFOCVCRCVCRA==\">https://github.com/microsoft/terminal/releases，下载</span> msixbundle 文件，双击即可安装。</p>\n<p>如果你已经安装了 WSL 和 Ubuntu，那么在 Windows Terminal 顶栏加号下拉处，就会显示一个 Ubuntu 的选项。点击即可快速打开 Ubuntu 的默认 shell。</p>\n<p><img data-src=\"https://tva1.sinaimg.cn/large/006VKfGmly1gxrq1meoapj30jj0actaq.jpg\" alt=\"Windows Terminal\" width=\"400px\" /></p>\n<h2 id=\"文件共享\"><a class=\"anchor\" href=\"#文件共享\">#</a> 文件共享</h2>\n<p>WSL 中的 Ubuntu 和你使用的 Windows，是两个隔离的系统，各自使用自己的文件系统。但是，隔离，但没完全隔离。</p>\n<p>Windows 的 C 盘，在 Ubuntu 中被挂载到了 /mnt/c，例如你要在 Linux 中访问 Windows 的桌面：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ <span class=\"token builtin class-name\">cd</span> /mnt/c/Users/Ziyang/Desktop</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ <span class=\"token function\">ls</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre> course.py     desktop.ini     szxx.bat     szxx.txt</pre></td></tr></table></figure><p>同样，如果想要在 Windows 上查看 WSL 自己的文件系统中的文件（例如～），可以通过如下命令，例如我想查看用户文件夹～：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ <span class=\"token builtin class-name\">cd</span> ~</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ explorer.exe <span class=\"token builtin class-name\">.</span></pre></td></tr></table></figure><p>这时会打开 Windows 的资源管理器，其中就是你要查看的文件夹的内容。你可以像操作 Windows 自己的文件夹一样操作它。</p>\n<h2 id=\"visual-studio-code\"><a class=\"anchor\" href=\"#visual-studio-code\">#</a> Visual Studio Code</h2>\n<p>vscode，世界上最好的文本编辑器，支持直接打开 WSL 中的文件夹，完全提供本地项目一般的体验。毕竟，不是所有人，都喜欢直接在 vim 里做实验的。</p>\n<p>首先打开 Windows 下的 vscode，在扩展商店中搜索 WSL，并安装 “Remote - WSL”，这个插件一般是这个关键词的第一个搜索结果。</p>\n<p>随后在 Ubuntu 中，在项目文件夹下，输入命令：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ code <span class=\"token builtin class-name\">.</span></pre></td></tr></table></figure><p>如果是第一次运行这个命令，会首先安装相关的支持组件：</p>\n<pre><code>$ code .\nInstalling VS Code Server for x64 (899d46d82c4c95423fb7e10e68eba52050e30ba3)\nDownloading: 100%\nUnpacking: 100%\n</code></pre>\n<p>随后就会自动打开 Windows 下的 vscode，并将 Ubuntu 中的项目文件夹作为工作目录，随后，想怎么开发就可以怎么开发了。</p>\n<h2 id=\"更换中国源\"><a class=\"anchor\" href=\"#更换中国源\">#</a> 更换中国源</h2>\n<p>首先明确，什么叫源：</p>\n<blockquote>\n<p><s>据古籍记载，天地合气生万物的时代，混沌迷蒙，灵气氤氲，非常浓密，很多灵物可以吸收天地间的本源精气，结出琥珀般的晶体，里面封有庞大的生命精华。</s><br />\n<s>保存到现在的，便被称作 “源”</s></p>\n</blockquote>\n<p>sorry，串了。</p>\n<p>简而言之，就是 Ubuntu，或者说 Debian 系使用的软件包管理器 apt，维护了一个 URL 列表，在用户通过 apt install 安装软件包时，会请求那些 URL 中搜索下载并安装。这个 URL 列表，就是源（sources）默认的 URL 都是国外的地址，由于众所周知的原因，速度很慢，甚至连接不了。所以需要将其更换为国内的源。</p>\n<p>方法如下：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ <span class=\"token function\">sudo</span> <span class=\"token function\">mv</span> /etc/apt/sources.list /etc/apt/sources.list.bak</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ <span class=\"token function\">sudo</span> <span class=\"token function\">nano</span> /etc/apt/sources.list</pre></td></tr></table></figure><p>将如下内容粘贴进去，这里我使用的是阿里的源。注意，不同的发行版，不同的版本，源是不同的，注意甄别。这里我用的是 Ubuntu 20.04 的源。</p>\n<pre><code>deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n</code></pre>\n<p>随后刷新源并更新软件包：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> upgrade</pre></td></tr></table></figure><h1 id=\"安装实验所需软件\"><a class=\"anchor\" href=\"#安装实验所需软件\">#</a> 安装实验所需软件</h1>\n<h2 id=\"软件包\"><a class=\"anchor\" href=\"#软件包\">#</a> 软件包</h2>\n<p>必要的就一句话：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> build-essential gcc-multilib gdb</pre></td></tr></table></figure><p>可选安装：cgdb。cgdb 是 GDB 的一个轻量级前端。它提供了一个分屏窗口，分别显示 gdb 命令界面（和默认 gdb 一样）和程序源码。由于软件源中的 cgdb 不是最新版本，于是从源码编译安装。方法如下：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> automake libncurses5-dev flex texinfo libreadline-dev</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ <span class=\"token function\">git</span> clone git://github.com/cgdb/cgdb.git</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>$ <span class=\"token builtin class-name\">cd</span> cgdb</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>$ ./autogen.sh</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>$ ./configure --prefix<span class=\"token operator\">=</span>/usr/local</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>$ <span class=\"token function\">make</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>$ <span class=\"token function\">sudo</span> <span class=\"token function\">make</span> <span class=\"token function\">install</span></pre></td></tr></table></figure><p>安装完成后，就可以在任何位置，通过 cgdb 命令打开了。如下：</p>\n<p><img data-src=\"https://tva1.sinaimg.cn/large/006VKfGmly1gxrrewr0hqj31fj0tmkhy.jpg\" alt=\"cgdb.png\" width=\"600px\" /></p>\n<p>左侧的窗口被称为代码窗口，右侧为 gdb 窗口。</p>\n<p>打开 cgdb 时，默认两个窗口是上下分隔的，可以通过  <code>ctrl+w</code>  切换成左右分隔模式。</p>\n<p>按 esc 键可以将焦点从 gdb 窗口转移到代码窗口，在代码窗口可以上下翻看源码，空格键可以在焦点行设置一个断点。</p>\n<p>按 i 键可以将焦点从代码窗口转移到 gdb 窗口，在 gdb 窗口的操作与普通 gdb 完全一致。</p>\n<p>更具体的 cgdb 使用可以查看这本 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV5aXcuZ2l0Ym9va3MuaW8vY2dkYi1tYW51YWwtaW4tY2hpbmVzZQ==\">CGDB 中文手册</span>。</p>\n<h2 id=\"实验在哪\"><a class=\"anchor\" href=\"#实验在哪\">#</a> 实验在哪？</h2>\n<p>如果你是自学 CSAPP，可以到这个网站：<span class=\"exturl\" data-url=\"aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUvM2UvbGFicy5odG1s\">http://csapp.cs.cmu.edu/3e/labs.html</span> ，每个实验后的 Self-Study Handout 连接就是实验材料的下载。传入 WSL，就可以快乐实验了！</p>\n",
            "tags": [
                "CSAPP",
                "lab"
            ]
        }
    ]
}